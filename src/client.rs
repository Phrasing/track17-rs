use std::time::Duration;

use anyhow::Result;
use wreq::{Client, header};
use wreq_util::Emulation;

use crate::credential::ApiCredentials;
use crate::credential_cache::CredentialCache;
use crate::proxy::ProxyConfig;
use crate::types::{Shipment, TrackingItem, TrackingRequest, TrackingResponse, carriers};

const API_URL: &str = "https://t.17track.net/track/restapi";

const INVALID_SIGN_CODE: i32 = -11;
const INVALID_SESSION_CODE: i32 = -14; // Session/cookie expired (empty shipments, empty guid)
const INVALID_UIP_CODE: i32 = -5; // Session invalid (uIP)
const PENDING_SHIPMENT_CODE: i32 = 100;
const NOT_FOUND_SHIPMENT_CODE: i32 = 400;
const PENDING_RETRY_DELAY: Duration = Duration::from_secs(2);
const MAX_PENDING_RETRIES: u32 = 10; // Avoid long loops on invalid sessions

/// Configuration for Track17Client
#[derive(Debug, Clone, Default)]
pub struct Track17Config {
    /// Proxy configuration
    pub proxy: Option<ProxyConfig>,
}

/// Thread-safe Track17 client that can be cloned and shared across threads.
///
/// # Concurrency
///
/// This client is designed for concurrent use. Multiple clones can track packages
/// in parallel, sharing credentials automatically. Ideal for batch processing
/// hundreds of orders concurrently.
///
/// # Credentials
///
/// Credentials (sign, cookies) are generated by:
/// - Fetching JS assets from 17track's CDN (cached for 1 hour)
/// - Running the sign module in an embedded V8 engine (fresh runtime per generation)
/// - Computing Last-Event-ID via pure Rust hashing
///
/// All tracking requests use HTTP via `wreq`.
///
/// Note: Credentials are shared across all client clones and cached for ~1-2 hours,
/// minimizing the need for regeneration.
///
/// # Example
///
/// ```no_run
/// use tracking_public_api::{Track17Client, carriers};
///
/// #[tokio::main]
/// async fn main() -> anyhow::Result<()> {
///     let client = Track17Client::new().await?;
///
///     // Spawn 10 concurrent tracking tasks
///     let tracking_numbers = vec!["123456789012", "234567890123"];
///     let handles: Vec<_> = tracking_numbers
///         .iter()
///         .map(|num| {
///             let client = client.clone();
///             let num = (*num).to_string();
///             tokio::spawn(async move {
///                 client.track(&num, carriers::AUTO).await
///             })
///         })
///         .collect();
///
///     // Wait for all to complete
///     for handle in handles {
///         let result = handle.await??;
///         println!("Status: {}", result.meta.message);
///     }
///
///     Ok(())
/// }
/// ```
#[derive(Clone)]
pub struct Track17Client {
    http_client: Client,
    _config: Track17Config,
    credential_cache: CredentialCache,
}

impl Track17Client {
    pub async fn new() -> Result<Self> {
        Self::with_config(Track17Config::default()).await
    }

    pub async fn with_proxy(proxy: Option<ProxyConfig>) -> Result<Self> {
        Self::with_config(Track17Config { proxy }).await
    }

    pub async fn with_config(config: Track17Config) -> Result<Self> {
        // Build HTTP client with optional proxy
        let mut http_builder = Client::builder()
            .emulation(Emulation::Chrome143)
            .cookie_store(true)
            .gzip(true)
            .brotli(true)
            .zstd(true);

        if let Some(ref proxy) = config.proxy {
            let proxy_url = proxy.to_url();
            http_builder = http_builder.proxy(wreq::Proxy::all(&proxy_url)?);
        }

        let http_client = http_builder.build()?;

        // Verify proxy by checking external IP
        if config.proxy.is_some()
            && let Ok(resp) = http_client.get("https://httpbin.org/ip").send().await
            && let Ok(body) = resp.text().await
            && let Ok(json) = serde_json::from_str::<serde_json::Value>(&body)
            && let Some(ip) = json.get("origin").and_then(|v| v.as_str())
        {
            eprintln!("Proxy IP: {}", ip);
        }

        let credential_cache = CredentialCache::new();

        Ok(Self {
            http_client,
            _config: config,
            credential_cache,
        })
    }

    /// Close the client and clean up resources.
    ///
    /// Note: This is a no-op since the client doesn't hold exclusive resources.
    /// Credentials and runtime are shared and will be cleaned up when all clones are dropped.
    pub async fn close(self) -> Result<()> {
        Ok(())
    }

    /// Ensure credentials are valid, regenerating if needed.
    ///
    /// Fast path (read lock): Returns cached credentials if still valid
    /// Slow path (write lock): Generates fresh credentials via V8
    async fn ensure_credentials(&self) -> Result<ApiCredentials> {
        // Fast path: read lock, check if valid
        if let Some(creds) = self.credential_cache.get_valid_credentials().await {
            return Ok(creds);
        }

        // Slow path: write lock, regenerate
        eprintln!("Generating credentials via V8...");
        let credentials = self
            .credential_cache
            .refresh_credentials(&self.http_client)
            .await?;
        eprintln!("Credentials generated!");

        Ok(credentials)
    }

    pub async fn track(
        &self,
        tracking_number: &str,
        carrier_code: u32,
    ) -> Result<TrackingResponse> {
        self.track_multiple(&[tracking_number.to_string()], carrier_code)
            .await
    }

    /// Make a single API request for tracking numbers
    async fn make_request(
        &self,
        items: &[TrackingItem],
        guid: &str,
        creds: &ApiCredentials,
    ) -> Result<TrackingResponse> {
        // Log request details
        eprintln!(
            "[track17-req] items={:?}, guid={}, sign_len={}, yq_bid_len={}",
            items
                .iter()
                .map(|i| format!("{}:{}", i.num, i.fc))
                .collect::<Vec<_>>(),
            if guid.is_empty() {
                "(empty)"
            } else {
                &guid[..guid.len().min(8)]
            },
            creds.sign.len(),
            creds.yq_bid.len(),
        );

        let request = TrackingRequest {
            data: items.to_vec(),
            guid: guid.to_string(),
            time_zone_offset: -480,
            sign: creds.sign.clone(),
        };

        let request_body = serde_json::to_string(&request)?;

        // Generate Last-Event-ID from the request body (only meaningful when guid is empty)
        let last_event_id = if guid.is_empty() {
            self.credential_cache
                .generate_last_event_id_for_body(&request_body)
                .await?
        } else {
            String::new()
        };

        let cookies = format!(
            "country=US; _yq_bid={}; v5_Culture=en; Last-Event-ID={}",
            creds.yq_bid, last_event_id
        );

        let mut req = self
            .http_client
            .post(API_URL)
            .header(header::REFERER, "https://t.17track.net/en")
            .header(header::COOKIE, &cookies)
            .header(header::ORIGIN, "https://t.17track.net");

        // Only send Last-Event-Id header on first request (empty guid)
        if guid.is_empty() && !last_event_id.is_empty() {
            req = req.header("last-event-id", &last_event_id);
        }

        let response = req.body(request_body).send().await?;

        let status = response.status();
        let body = response.text().await?;

        // Log raw response (truncated for readability)
        eprintln!(
            "[track17-resp] status={}, body_len={}, body_preview={}",
            status,
            body.len(),
            &body[..body.len().min(500)]
        );

        if !status.is_success() {
            anyhow::bail!("API request failed: {} {}", status, body);
        }

        serde_json::from_str(&body).map_err(|e| anyhow::anyhow!("Failed to parse response: {}", e))
    }

    /// Check if a shipment needs more polling
    fn shipment_needs_retry(shipment: &Shipment) -> bool {
        // Code 100 = pending registration - always retry
        if shipment.code == PENDING_SHIPMENT_CODE {
            return true;
        }
        // Code 200 = success. Only retry if we have no shipment data at all.
        // Accept shipments even without events - some carriers may not have
        // event data immediately available, but the shipment is still valid.
        if shipment.code == 200 {
            // If we have shipment details, accept it (even without events)
            // Only retry if shipment is completely None
            return shipment.shipment.is_none();
        }
        false
    }

    /// Extract suggested carrier from code 400 response
    fn get_suggested_carrier(shipment: &Shipment) -> Option<u32> {
        shipment.extra.as_ref()?.iter().find_map(|e| {
            // Prefer FedEx if available, otherwise take first carrier
            if e.multi.contains(&carriers::FEDEX) {
                Some(carriers::FEDEX)
            } else if e.multi.contains(&carriers::UPS) {
                Some(carriers::UPS)
            } else if e.multi.contains(&carriers::USPS) {
                Some(carriers::USPS)
            } else {
                e.multi.first().copied()
            }
        })
    }

    pub async fn track_multiple(
        &self,
        tracking_numbers: &[String],
        carrier_code: u32,
    ) -> Result<TrackingResponse> {
        // Get credentials, generating if needed (runs V8 briefly)
        let mut current_creds = self.ensure_credentials().await?;

        let mut pending_retries = 0;
        let mut session_guid = String::new();

        // Track state per tracking number: (number, carrier, resolved_shipment)
        let mut items: Vec<TrackingItem> = tracking_numbers
            .iter()
            .map(|num| TrackingItem {
                num: num.clone(),
                fc: carrier_code,
                sc: 0,
            })
            .collect();

        // Final results map: number -> shipment
        let mut final_shipments: std::collections::HashMap<String, Shipment> =
            std::collections::HashMap::new();

        // Store last response for each tracking number (used when max retries exceeded)
        let mut last_shipments: std::collections::HashMap<String, Shipment> =
            std::collections::HashMap::new();

        loop {
            // Filter to items not yet resolved
            let pending_items: Vec<TrackingItem> = items
                .iter()
                .filter(|item| !final_shipments.contains_key(&item.num))
                .cloned()
                .collect();

            if pending_items.is_empty() {
                break;
            }

            let response = self
                .make_request(&pending_items, &session_guid, &current_creds)
                .await?;

            // Log parsed response details
            eprintln!(
                "[track17-parsed] meta.code={}, meta.message={}, guid={}, shipments: [{}]",
                response.meta.code,
                response.meta.message,
                if response.guid.is_empty() {
                    "(empty)"
                } else {
                    &response.guid[..response.guid.len().min(8)]
                },
                response
                    .shipments
                    .iter()
                    .map(|s| format!(
                        "{}:code={},has_shipment={},has_events={}",
                        s.number,
                        s.code,
                        s.shipment.is_some(),
                        s.shipment
                            .as_ref()
                            .map(|d| d.latest_event.is_some()
                                || d.tracking
                                    .as_ref()
                                    .and_then(|t| t.providers.as_ref())
                                    .map(|p| p.iter().any(|prov| !prov.events.is_empty()))
                                    .unwrap_or(false))
                            .unwrap_or(false)
                    ))
                    .collect::<Vec<_>>()
                    .join(", ")
            );

            // Handle sign/session expiration - need to re-generate credentials
            let is_uip = response.meta.message.to_lowercase().contains("uip");
            if response.meta.code == INVALID_SIGN_CODE
                || response.meta.code == INVALID_SESSION_CODE
                || response.meta.code == INVALID_UIP_CODE
                || is_uip
            {
                eprintln!(
                    "Credentials expired (code {}), refreshing...",
                    response.meta.code
                );

                // Invalidate cache (drops runtime, clears credentials and assets)
                self.credential_cache.invalidate().await;

                // Regenerate credentials
                current_creds = self.ensure_credentials().await?;
                continue;
            }

            // Store GUID for subsequent requests
            if !response.guid.is_empty() {
                session_guid = response.guid.clone();
            }

            // Process each shipment
            for shipment in response.shipments {
                let num = shipment.number.clone();

                // Code 400 with carrier suggestions - retry with suggested carrier
                if shipment.code == NOT_FOUND_SHIPMENT_CODE
                    && let Some(suggested) = Self::get_suggested_carrier(&shipment)
                {
                    eprintln!(
                        "Auto-detect failed for {}, retrying with carrier {}",
                        num, suggested
                    );
                    // Update the item's carrier for next iteration
                    if let Some(item) = items.iter_mut().find(|i| i.num == num) {
                        item.fc = suggested;
                    }
                    continue;
                }

                // Always store the last response (used as fallback when max retries exceeded)
                last_shipments.insert(num.clone(), shipment.clone());

                // Check if this shipment is complete
                if !Self::shipment_needs_retry(&shipment) {
                    final_shipments.insert(num, shipment);
                }
            }

            // Check if we still have pending items that need retry
            let still_pending = items
                .iter()
                .filter(|item| !final_shipments.contains_key(&item.num))
                .count();

            if still_pending > 0 {
                // Log retry decision
                eprintln!(
                    "[track17-retry] pending={}, retry_count={}/{}",
                    still_pending,
                    pending_retries + 1,
                    MAX_PENDING_RETRIES
                );

                if pending_retries >= MAX_PENDING_RETRIES {
                    // Max retries reached, use last response data instead of placeholders
                    eprintln!(
                        "Max retries reached, accepting last response data for remaining packages"
                    );
                    for item in &items {
                        if !final_shipments.contains_key(&item.num) {
                            // Use last response if available, otherwise create placeholder
                            if let Some(last_shipment) = last_shipments.remove(&item.num) {
                                eprintln!(
                                    "Accepting incomplete data for {}: code={}, has_shipment={}",
                                    item.num,
                                    last_shipment.code,
                                    last_shipment.shipment.is_some()
                                );
                                final_shipments.insert(item.num.clone(), last_shipment);
                            } else {
                                // No response at all - create placeholder
                                final_shipments.insert(
                                    item.num.clone(),
                                    Shipment {
                                        code: PENDING_SHIPMENT_CODE,
                                        number: item.num.clone(),
                                        carrier: item.fc,
                                        carrier_final: None,
                                        param: None,
                                        params: None,
                                        params_v2: None,
                                        extra: None,
                                        shipment: None,
                                        pre_status: None,
                                        prior_status: None,
                                        state: None,
                                        state_final: None,
                                        service_type: None,
                                        service_type_final: None,
                                        key: None,
                                        show_more: false,
                                    },
                                );
                            }
                        }
                    }
                    break;
                }

                pending_retries += 1;
                eprintln!(
                    "Tracking data incomplete for {} package(s), retrying ({}/{})...",
                    still_pending, pending_retries, MAX_PENDING_RETRIES
                );
                tokio::time::sleep(PENDING_RETRY_DELAY).await;
            }
        }

        // Build final response preserving original order
        let shipments: Vec<Shipment> = tracking_numbers
            .iter()
            .filter_map(|num| final_shipments.remove(num))
            .collect();

        Ok(TrackingResponse {
            id: 0,
            guid: session_guid,
            shipments,
            meta: crate::types::Meta {
                code: 200,
                message: "Ok".to_string(),
            },
        })
    }
}
